<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <canvas id="canvas"></canvas>
  <div id="point"></div>
</body>
<script>
  class BackstitchMarker {
    static get epsilon() { return 20; }

    constructor(ctx, backstitch, touchX, touchY) {
      this.ctx = ctx;
      this.backstitch = backstitch;

      this.setBackstitchPoints(backstitch, touchX, touchY);

      this.move = this.move.bind(this);
      this.ctx.canvas.addEventListener("mousemove", this.move);
    }

    move(event) {
      const moveContext = this.getPointOnBackstitch(event.offsetX, event.offsetY);

      // TODO: Fire event that backstitch marking progressed.
      moveContext && this.draw(moveContext.x, moveContext.y);
    }

    getPointOnBackstitch(x, y) {
      const startPoint = this.startPoint;
      const endPoint = this.endPoint;
      const distanceToStart = Math.sqrt(Math.pow(startPoint.x - x, 2) + Math.pow(startPoint.y - y, 2));
      const distanceToEnd = Math.sqrt(Math.pow(endPoint.x - x, 2) + Math.pow(endPoint.y - y, 2));
      const backstitchLength = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
      const distanceToBackstitch = this.getDistanceToBackstith(distanceToStart, distanceToEnd, backstitchLength);

      if (distanceToBackstitch < BackstitchMarker.epsilon) {
        const cathetus = Math.sqrt(Math.pow(distanceToStart, 2) - Math.pow(distanceToBackstitch, 2));

        let ab = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
        let bc = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - endPoint.y, 2));
        let ac = Math.sqrt(Math.pow(startPoint.x - startPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));

        let dX = cathetus * bc / ab;
        let dY = cathetus * ac / ab;
        const deviationX = [dX, -dX];
        const deviationY = [dY, -dY];

        for (let i = 0; i < deviationX.length; i++) {
          const backstitchX = startPoint.x + deviationX[i];
          for (let j = 0; j < deviationY.length; j++) {
            const backstitchY = startPoint.y + deviationY[j];
            const inbetween = Math.min(startPoint.x, endPoint.x) <= backstitchX && backstitchX <= Math.max(startPoint.x, endPoint.x) && Math.min(startPoint.y, endPoint.y) <= backstitchY && backstitchY <= Math.max(startPoint.y, endPoint.y);
            const matchesDistance = Math.abs(Math.sqrt((Math.pow(x - backstitchX, 2) + Math.pow(y - backstitchY, 2))) - distanceToBackstitch) < 0.00001;
            if (inbetween && matchesDistance) {
              const pointOnBackstitch = { x: backstitchX, y: backstitchY };
              const backstitchPointToStart = Math.sqrt(Math.pow(startPoint.x - pointOnBackstitch.x, 2) + Math.pow(startPoint.y - pointOnBackstitch.y, 2));
              const backstitchPointToEnd = Math.sqrt(Math.pow(endPoint.x - pointOnBackstitch.x, 2) + Math.pow(endPoint.y - pointOnBackstitch.y, 2));
              if (backstitchPointToStart < backstitchLength && backstitchPointToEnd < backstitchLength) {

                // TODO: Fire event directly here. Move the code to move method.
                return pointOnBackstitch;
              }
              else {
                // TODO: Call dispose from layer as reaction to the event.
                this.dispose();

                // TODO: Fire event that marking was aborted.
                drawBackstitch(this.ctx, this.backstitch);
              }
            }
          }
        }
      } else {
        this.stopDrawing();
      }

      return null;
    }

    draw(x, y) {
      const startPoint = this.startPoint;
      const endPoint = this.endPoint;
      let distanceToEnd = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)) - Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2))

      if (distanceToEnd < BackstitchMarker.epsilon) {
        this.ctx.beginPath();
        this.ctx.moveTo(this.startPoint.x, this.startPoint.y);
        this.ctx.lineTo(this.endPoint.x, this.endPoint.y);
        this.ctx.lineWidth = 5;
        this.ctx.strokeStyle = "blue";
        this.ctx.stroke();
        this.ctx.closePath();
        this.finalize();
      } else {
        drawBackstitch(this.ctx, this.backstitch);
        this.ctx.beginPath();
        this.ctx.moveTo(this.startPoint.x, this.startPoint.y);
        this.ctx.lineTo(x, y);
        this.ctx.lineWidth = 5;
        this.ctx.strokeStyle = "blue";
        this.ctx.stroke();
        this.ctx.closePath();

        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(this.endPoint.x, this.endPoint.y);
        this.ctx.lineWidth = 5;
        this.ctx.strokeStyle = "green";
        this.ctx.stroke();
        this.ctx.closePath();
      }
    }

    getDistanceToBackstith(distanceToStart, distanceToEnd, backstitchLength) {
      let halfPerimeter = (distanceToStart + distanceToEnd + backstitchLength) * 0.5;
      let area = Math.sqrt(halfPerimeter * (halfPerimeter - distanceToStart) * (halfPerimeter - distanceToEnd) * (halfPerimeter - backstitchLength));
      let distanceToBackstitch = (area * 2 / backstitchLength);
      return distanceToBackstitch;
    }

    setBackstitchPoints(backstitch, touchX, touchY) {
      if (backstitch.startPoint.x - BackstitchMarker.epsilon < touchX && touchX < backstitch.startPoint.x + BackstitchMarker.epsilon && backstitch.startPoint.y - BackstitchMarker.epsilon < touchY && touchY < backstitch.startPoint.y + BackstitchMarker.epsilon) {
        this.startPoint = { x: backstitch.startPoint.x, y: backstitch.startPoint.y };
        this.endPoint = { x: backstitch.endPoint.x, y: backstitch.endPoint.y };
      } else {
        this.startPoint = { x: backstitch.endPoint.x, y: backstitch.endPoint.y };
        this.endPoint = { x: backstitch.startPoint.x, y: backstitch.startPoint.y };
      }
    }

    finalize() {
      // TODO: fire event that backstitch is completed

      // TODO: Dispose from layer.
      this.dispose();
    }

    stopDrawing() {
      // TODO: Call dispose from layer as reaction to the event.
      this.dispose();

      // TODO: Fire event that marking was aborted.
      drawBackstitch(this.ctx, this.backstitch);
    }

    dispose() {
      this.ctx.canvas.removeEventListener("mousemove", this.move);
    }
  }

  let marker;
  init();

  function init() {
    // let x1 = 300;
    // let y1 = 100;
    // let x2 = 200;
    // let y2 = 300;

    let x1 = 100;
    let y1 = 100;
    let x2 = 200;
    let y2 = 300;

    // let x1 = 200;
    // let y1 = 300;
    // let x2 = 100;
    // let y2 = 100;

    // let x1 = 100;
    // let y1 = 200;
    // let x2 = 300;
    // let y2 = 100;

    // let x1 = 100;
    // let y1 = 200;
    // let x2 = 100;
    // let y2 = 100;

    // let x1 = 100;
    // let y1 = 200;
    // let x2 = 300;
    // let y2 = 200;

    let backstitch = { startPoint: { x: x1, y: y1 }, endPoint: { x: x2, y: y2 } };
    let pointerLocation = null;
    let ctx = getContext();
    drawBackstitch(ctx, backstitch);

    //touchstart creates marker
    ctx.canvas.onmousedown = (e) => {
      document.getElementById("point").innerText = `x: ${e.offsetX}, y: ${e.offsetY}`;
      marker = new BackstitchMarker(ctx, backstitch, e.offsetX, e.offsetY);
    }
    ctx.canvas.onmouseup = () => marker.stopDrawing();
  }

  function getContext() {
    let ctx = document.getElementById("canvas").getContext("2d");
    ctx.canvas.width = 500;
    ctx.canvas.height = 500;
    return ctx;
  }

  function drawBackstitch(ctx, backstitch) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = "black";
    ctx.strokeRect(1, 1, ctx.canvas.width - 1, ctx.canvas.height - 1);

    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "orange";
    ctx.arc(backstitch.startPoint.x, backstitch.startPoint.y, BackstitchMarker.epsilon, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.closePath();

    ctx.beginPath();
    ctx.strokeStyle = "brown";
    ctx.arc(backstitch.endPoint.x, backstitch.endPoint.y, BackstitchMarker.epsilon, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.closePath();

    ctx.beginPath();
    ctx.strokeStyle = "red";
    ctx.arc(backstitch.endPoint.x, backstitch.endPoint.y, 1, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.closePath();

    ctx.beginPath();
    ctx.arc(backstitch.startPoint.x, backstitch.startPoint.y, 1, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.closePath();

    ctx.beginPath();
    ctx.moveTo(backstitch.startPoint.x, backstitch.startPoint.y);
    ctx.lineTo(backstitch.endPoint.x, backstitch.endPoint.y);
    ctx.lineWidth = 5;
    ctx.strokeStyle = "green";
    ctx.stroke();
    ctx.closePath();
  }
</script>

</html>



































































<!-- ROUNDED RECTANGLE -->

<!--  -->

<!-- <!DOCTYPE HTML>
<html>

<head>
    <style>
        body {
            margin: 0px;
            padding: 0px;
        }
    </style>
</head>

<body>
    <canvas id="rounded-rect" width="500" distanceToBackstitch="200">
      </canvas>
    <script>
// Now you can just call
var ctx = document.getElementById("rounded-rect").getContext("2d");
// Draw using default border radius, 
// stroke it but no fill (function's default values)
roundRect(ctx, 5, 5, 50, 50);
// To change the color on the rectangle, just manipulate the context
ctx.strokeStyle = "rgb(255, 0, 0)";
ctx.fillStyle = "rgba(255, 255, 0, .5)";
roundRect(ctx, 100, 5, 100, 100, 20, true);
// Manipulate it again
ctx.strokeStyle = "#0f0";
ctx.fillStyle = "#ddd";
// Different radii for each corner, others default to 0
roundRect(ctx, 300, 5, 200, 100, {
  tl: 50,
  br: 25
}, true);

/**
 * Draws a rounded rectangle using the current state of the canvas.
 * If you omit the last three params, it will draw a rectangle
 * outline with a 5 pixel border radius
 * @param {CanvasRenderingContext2D} ctx
 * @param {Number} x The top left x coordinate
 * @param {Number} y The top left y coordinate
 * @param {Number} width The width of the rectangle
 * @param {Number} distanceToBackstitch The distanceToBackstitch of the rectangle
 * @param {Number} [radius = 5] The corner radius; It can also be an object 
 *                 to specify different radii for corners
 * @param {Number} [radius.tl = 0] Top left
 * @param {Number} [radius.tr = 0] Top right
 * @param {Number} [radius.br = 0] Bottom right
 * @param {Number} [radius.bl = 0] Bottom left
 * @param {Boolean} [fill = false] Whether to fill the rectangle.
 * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
 */
function roundRect(ctx, x, y, width, distanceToBackstitch, radius, fill, stroke) {
  if (typeof stroke == 'undefined') {
    stroke = true;
  }
  if (typeof radius === 'undefined') {
    radius = 5;
  }
  if (typeof radius === 'number') {
    radius = {tl: radius, tr: radius, br: radius, bl: radius};
  } else {
    var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
    for (var side in defaultRadius) {
      radius[side] = radius[side] || defaultRadius[side];
    }
  }
  ctx.beginPath();
  ctx.moveTo(x + radius.tl, y);
  ctx.lineTo(x + width - radius.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  ctx.lineTo(x + width, y + distanceToBackstitch - radius.br);
  ctx.quadraticCurveTo(x + width, y + distanceToBackstitch, x + width - radius.br, y + distanceToBackstitch);
  ctx.lineTo(x + radius.bl, y + distanceToBackstitch);
  ctx.quadraticCurveTo(x, y + distanceToBackstitch, x, y + distanceToBackstitch - radius.bl);
  ctx.lineTo(x, y + radius.tl);
  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
  ctx.closePath();
  if (fill) {
    ctx.fill();
  }
  if (stroke) {
    ctx.stroke();
  }

}
    </script>
</body>

</html> -->






<!-- GRID -->

<!--  -->

<!-- <!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <canvas id="1"></canvas>
</body>
<script>
    let canvas = document.getElementById("1");
    canvas.width = 300;
    canvas.distanceToBackstitch = 300;
    let ctx = canvas.getContext("2d");
    // ctx.strokeRect(0, 0, 300, 300);
    let stitchSize = 25;
    let amountOfLines = Math.floor(canvas.width / stitchSize);
    for (let j = 1; j < amountOfLines; j++) {
        ctx.beginPath();
        ctx.moveTo(0, stitchSize * j);
        ctx.lineTo(canvas.width, stitchSize * j);
        ctx.stroke();
    }
    for (let i = 1; i < amountOfLines; i++) {
        ctx.beginPath();
        ctx.moveTo(stitchSize * i, 0);
        ctx.lineTo(stitchSize * i, canvas.distanceToBackstitch);
        ctx.stroke();
    }
</script>

</html>
 -->













<!-- CREATE CUSTOM EVENT LISTENER -->

<!--  -->

<!-- <script>
    class EventDispatcher {
        constructor() {
            this.events = {};
        }

        addEventListener(type, listener) {
            this.events[type] = this.events[type] || [];
            this.events[type].push(listener);
        }

        dispatchEvent(event) {
            if (this.events[event.type])
                this.events[event.type].forEach(listener => listener(event));
        }
    }

    class Stitch extends EventDispatcher {
        constructor() {
            super();
        }
    }
    var stitch = new Stitch();

    var tile1 = new Object();
    var tile2 = new Object();
    tile1.draw = function (event) {
        console.log("HELLO FROM TILE 1");
    }
    tile2.draw = function (event) {
        console.log("HELLO FROM TILE 2");
    }

    console.log(stitch);

    stitch.addEventListener("marked", tile1.draw);
    stitch.addEventListener("marked", tile2.draw);
    stitch.dispatchEvent(new CustomEvent("marked"));

</script> -->


<!-- JS CREATE OWN CUSTOM EVENT LISTENERS -->

<!--  -->

<!-- let EventListener = function () {
    this.events = []; // Empty list of events/actions
}

EventListener.prototype.on = function (event, fn) {
    this.events[event] = this.events[event] || [];
    this.events[event].push(fn);
}

EventListener.prototype.fire = function (event) {
    if (this.events[event]) {
        this.events[event].forEach(function (fn) {
            fn();
        })
    }
}

var EvListener = new EventListener();


// Initializes the event listener

// Adding events and callbacks
EvListener.on("make-coffee", function () {
    console.log("Here is your coffee, Sir.");
});

EvListener.on("make-coffee", function () {
    console.log("Thank you darling.");
});

EvListener.on("no-more-coffee", function () {
    console.log("We need more coffeeâ€¦");
});

// Firing events
EvListener.fire("make-coffee");
EvListener.fire("no-more-coffee");
 -->

<!--  -->







<!-- ADD CANVAS USING JS -->

<!--  -->

<!-- <!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <canvas id="can1" width="500" distanceToBackstitch="500"></canvas>
</body>
<script>
    class World {
        hello() {
            alert("hi");
        }

        hi() {
            this.hello();
        }
    }


    let ctx1 = document.getElementById("can1").getContext("2d");

    let canvas = document.createElement("canvas");
    canvas.width = document.getElementById("can1").width;
    canvas.distanceToBackstitch = document.getElementById("can1").distanceToBackstitch;
    canvas.id = "can2";
    document.body.appendChild(canvas);

    let image = new Image();
    let ctx2 = canvas.getContext("2d");
    ctx2.rect(0, 0, 500, 500);
    ctx2.stroke();

    for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 5; j++) {
            debugger;
            ctx1.fillRect(100 * i, 100 * j, 100, 100);
            ctx2.drawImage(ctx1.canvas, 0, 0);
        }
    }

</script>

</html> -->

<!--  -->






<!-- KEYWORD BIND -->

<!--  -->

<!-- <script>
    var f = function(){
        console.log(this);
    }
    var x = f.bind("sd");
    x();
</script> -->

<!--  -->
